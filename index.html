<!DOCTYPE html>
<html>
<head>
  <meta name="baidu-site-verification" content="codeva-nIjDp6ZZc0" />
  <meta name="referrer" content="no-referrer"/>
  <meta charset="utf-8">
  

  
  <title>凝雪密境</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="卡卡希的吐槽圣地">
<meta property="og:type" content="website">
<meta property="og:title" content="凝雪密境">
<meta property="og:url" content="https://blog.cchealthier.com/index.html">
<meta property="og:site_name" content="凝雪密境">
<meta property="og:description" content="卡卡希的吐槽圣地">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ChrisIori">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  <link href="https://www.jq22.com/demo/jqueryToast201708310012/css/toast.style.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/highlight/styles/monokai-sublime.min.css">
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">凝雪密境</a>
      </h1>
      
        <div id="avatar" style="background-image: url( /avatar.jpg )">
          <div class="container">
            <div class="ball wind"></div>
            <div class="ball fire"></div>
            <div class="ball water"></div>
            <div class="ball soil"></div>
          </div>
        </div>
      
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.cchealthier.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-react-native-ffmpegkit-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/08/17/react-native-ffmpegkit-3/" class="article-date">
  <time datetime="2025-08-17T14:34:28.000Z" itemprop="datePublished">2025-08-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/08/17/react-native-ffmpegkit-3/">react-native 集成 FFmpeg 能力 - 使用 FFmpegKit（三）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>相关文章：<br>《<a href="/2025/07/27/react-native-ffmpegkit/">react-native 集成 FFmpeg 能力 - 使用 FFmpegKit（一）</a>》<br>《<a href="/2025/08/02/react-native-ffmpegkit-2/">react-native 集成 FFmpeg 能力 - 使用 FFmpegKit（二）</a>》</p>
<p><strong><u>这一篇主要记录自己尝试打包 FFmpegKit 遇到的一些问题</u></strong></p>
<p>FFmpegKit <a target="_blank" rel="noopener" href="https://github.com/arthenica/ffmpeg-kit/tree/main">仓库地址</a></p>
<p>网上可以找到一些大佬打好的全功能包，但是有些功能可能用不上，自己不需要的话，可以尝试自己本地编译一个。<br>仓库作者大佬也把怎么打写在文档里了，包括多平台的。这里我只尝试打包 apple 和 android 的。</p>
<h3 id="0、"><a href="#0、" class="headerlink" title="0、"></a>0、</h3><p>首先最后一步是需要 x86 架构才能打出来，如果是苹果芯片电脑，需要安装 <a target="_blank" rel="noopener" href="https://support.apple.com/zh-cn/guide/motion/aside/motnd9f51338/5.6.6/mac/13.4">Rosetta</a> 工具。否则会报这样的错：<br><code>arch: posix_spawnp: zsh: Bad CPU type in executable</code></p>
<p>先查看自己电脑有没有安装：</p>
<pre><code class="bash">pgrep -q oahd &amp;&amp; echo &quot;Rosetta 已安装&quot; || echo &quot;Rosetta 未安装&quot;
</code></pre>
<p>没有的话就进行安装</p>
<pre><code class="bash">softwareupdate --install-rosetta
</code></pre>
<p>接着安装文档安装一系列必备的依赖和一些环境变量的设置，比如 android 需要设置 sdk 和 ndk 的路径。</p>
<p>其他问题：</p>
<h3 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h3><p>可能会遇到需要升级 bison 的问题，电脑自带的可能才 2.3，可以用 homebrew 下载新的版本，然后覆盖电脑自带的<br>相关 issue 《<a target="_blank" rel="noopener" href="https://github.com/arthenica/ffmpeg-kit/issues/201">fails to build with –enable-gnutls</a>》。</p>
<h3 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h3><p>可能会遇到 cmake 最低版本要求，报错：CMake Error at CMakeLists.txt:29 (cmake_minimum_required):<br>去相应的 CMakeLists.txt 文件，把 cmake_minimum_required (VERSION 3.1 FATAL_ERROR)  这一句的那个 3.1 数据改成 3.5</p>
<h3 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h3><p>用 —full 的时候，可能最后打包会报错，openssl 和 gnutls 不能同时启动。所以改成不要用 —full，按官网 readme 把所需要的参数一个个 enable 进去。二选一，deepseek 推荐用 openssl</p>
<h3 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h3><p>Android ndk 版本最好用 25.1.8937393，其他版本我试了都报错。</p>
<h3 id="5、"><a href="#5、" class="headerlink" title="5、"></a>5、</h3><p>报了一个缺失库的错误，记不太清楚了。是有一份文件有关于头文件引入的判断，大概是判断要引入类似于这样的库： &lt;f.h&gt; 还是 &lt;math.h&gt;，然后条件判断是要引入 &lt;f.h&gt;。结果这个库比较老导致报错了。我就尝试都改成使用 &lt;math.h&gt; 就通过了。具体是哪一份文件的哪一行记不住了。<br>本来文章就是想记录这个，结果却忘了。&#x3D; &#x3D;!</p>

      
    </div>
    <footer class="article-footer">
      
      <!-- <a data-url="https://blog.cchealthier.com/2025/08/17/react-native-ffmpegkit-3/" data-id="cmefuc51i003let9mh0ly8c4z" class="article-share-link">分享</a> -->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ffmpegkit/" rel="tag">ffmpegkit</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react-native/" rel="tag">react-native</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-native-ffmpegkit-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/08/02/react-native-ffmpegkit-2/" class="article-date">
  <time datetime="2025-08-02T07:36:21.000Z" itemprop="datePublished">2025-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/08/02/react-native-ffmpegkit-2/">react-native 集成 FFmpeg 能力 - 使用 FFmpegKit（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>相关文章：<br>《<a href="/2025/07/27/react-native-ffmpegkit/">react-native 集成 FFmpeg 能力 - 使用 FFmpegKit（一）</a>》<br>《<a href="/2025/08/17/react-native-ffmpegkit-3/">react-native 集成 FFmpeg 能力 - 使用 FFmpegKit（三）</a>》</p>
<p><strong><u>这一篇主要记录对于 react-native 项目里，直接使用原生模块。</u></strong></p>
<p>其实 react-native 能用起来，那就意味着原生的引入已经成功了。但是我以为和上一篇处理 react-native 库一样，在根目录的 ios 和 android 文件夹引入声明，相当于全局声明，自定义原生模块就可以直接使用了，但实际上不是，还需要在相应的自定义原生模块里再引入声明。</p>
<p>expo 项目有可以协助创建自定义原生模块的 <a target="_blank" rel="noopener" href="https://docs.expo.dev/modules/native-module-tutorial/">create-expo-module</a>。然后前提还是先把 ffmpegkit 的库下到本地来引入。</p>
<h3 id="1-expo-项目-Android-引入"><a href="#1-expo-项目-Android-引入" class="headerlink" title="1. expo 项目 Android 引入"></a>1. expo 项目 Android 引入</h3><p>在 <code>modules/native-module/android/build.gradle</code> 加上：</p>
<pre><code>dependencies &#123;
    // 1. 直接引入 AAR，位置合理放置就行
    implementation files(&#39;libs/ffmpeg-kit-full-6.0-2.aar&#39;)
    // 2. 添加传递依赖（必须）
    implementation &#39;com.arthenica:smart-exception-java:0.2.1&#39;
&#125;
</code></pre>
<p>在代码里使用：</p>
<pre><code class="kotlin">package expo.modules.settings

// 引入下面这三个
import com.arthenica.ffmpegkit.FFmpegKit
import com.arthenica.ffmpegkit.FFmpegSession
import com.arthenica.ffmpegkit.ReturnCode

import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition

class ExpoSettingsModule : Module() &#123;
  override fun definition() = ModuleDefinition &#123;
    Name(&quot;ExpoSettings&quot;)

    Function(&quot;getTheme&quot;) &#123;
      return@Function &quot;system&quot;
    &#125;
  &#125;
&#125;
</code></pre>
<h3 id="2-expo-项目-IOS-引入"><a href="#2-expo-项目-IOS-引入" class="headerlink" title="2. expo 项目 IOS 引入"></a>2. expo 项目 IOS 引入</h3><p>在 <code>modules/native-module/ios/NativeModule.podspec</code> 加上：</p>
<pre><code class="pod">Pod::Spec.new do |s|
  s.name           = &#39;NativeModule&#39;
  s.version        = &#39;1.0.0&#39;
  s.summary        = &#39;&#39;
  s.description    = &#39;&#39;
  s.author         = &#39;&#39;
  s.homepage       = &#39;https://docs.expo.dev/modules/&#39;
  s.platforms      = &#123;
    :ios =&gt; &#39;15.1&#39;,
    :tvos =&gt; &#39;15.1&#39;
  &#125;
  s.source         = &#123; git: &#39;&#39; &#125;
  s.static_framework = true

  s.dependency &#39;ExpoModulesCore&#39;

  # Swift/Objective-C compatibility
  s.pod_target_xcconfig = &#123;
    &#39;DEFINES_MODULE&#39; =&gt; &#39;YES&#39;,
  &#125;

  s.source_files = &quot;src/**/*.&#123;h,m,mm,swift,hpp,cpp&#125;&quot;
  // 直接引入 xcframework， 位置合理放置就行
  s.vendored_frameworks = &#39;libs/*.xcframework&#39;
end
</code></pre>
<p>在代码里使用：</p>
<pre><code class="swift">import ExpoModulesCore

// 加上这句引用
import ffmpegkit

public class ExpoSettingsModule: Module &#123;
  public func definition() -&gt; ModuleDefinition &#123;
    Name(&quot;ExpoSettings&quot;)

    Function(&quot;getTheme&quot;) &#123; () -&gt; String in
      &quot;system&quot;
    &#125;
  &#125;
&#125;
</code></pre>
<p><strong>下面两个只是尝试，然后记录一下，实际上用的上面 expo 项目</strong></p>
<h3 id="3-react-native-项目-IOS-引入，-使用-swift-语法"><a href="#3-react-native-项目-IOS-引入，-使用-swift-语法" class="headerlink" title="3. react-native 项目 IOS 引入， 使用 swift 语法"></a>3. react-native 项目 IOS 引入， 使用 swift 语法</h3><p>本质上差别不大，只是没有 expo 的辅助，改回 react-native 要求的语法。</p>
<p>在 <code>modules/native-module/src/NativeModule.ts</code> 改成：</p>
<pre><code class="ts">// expo 改成 react-native 的模块引入方式
import &#123; NativeModules &#125; from &#39;react-native&#39;;
export const NewVideoEditor = NativeModules.NewVideoEditorModule;
</code></pre>
<p><code>podspec</code> 文件和 expo 项目一样就行。</p>
<p>新增 <code>modules/new-module/ios/src/NativeModule.m</code> 文件：</p>
<pre><code class="Objective-c">#import &lt;React/RCTBridgeModule.h&gt;
#import &lt;FFmpegKit/FFmpegKit.h&gt;

@interface RCT_EXTERN_MODULE(NewVideoEditorModule, NSObject)

// 同步方法 - getName
RCT_EXTERN_METHOD(getName)

// 异步方法 - getFFmpegVersion
RCT_EXTERN_METHOD(getFFmpegVersion:(RCTPromiseResolveBlock)resolve
                  rejecter:(RCTPromiseRejectBlock)reject)

@end
</code></pre>
<p>新增 <code>modules/new-module/ios/src/NativeModule.swift</code> 文件：</p>
<pre><code class="swift">import Foundation
import React
import ffmpegkit

@objc(NewVideoEditorModule)
class NewVideoEditorModule: NSObject, RCTBridgeModule &#123;
    // MARK: - RCTBridgeModule
    static func moduleName() -&gt; String! &#123;
        return &quot;NewVideoEditorModule&quot;
    &#125;
    static func requiresMainQueueSetup() -&gt; Bool &#123;
        return false
    &#125;
    // MARK: - Exported Methods
    // 导出同步方法 - 使用 @objc 标记，React Native 会自动发现
    @objc
    func getName() -&gt; String &#123;
        return &quot;NewVideoEditor-Name&quot;
    &#125;
    @objc
    func getFFmpegVersion(_ resolve: @escaping RCTPromiseResolveBlock,
                         rejecter reject: @escaping RCTPromiseRejectBlock) &#123;
        let version = FFmpegKitConfig.getFFmpegVersion()
        resolve(version)
    &#125;
&#125;
</code></pre>
<p>上面的代码也是问 AI 问出来的，仅供参考，模块名和文件名需要按实际填写。这里的注意点还是原生 ios 的问题吧，据说 ios 提供给 react-native 的库是用 Objective-c 写的。所以在 react-native 里自定义原生 ios 模块里写 swift 也要包装成 Objective-c。</p>
<h3 id="4-react-native-项目-IOS-引入，-使用-Objective-c-语法"><a href="#4-react-native-项目-IOS-引入，-使用-Objective-c-语法" class="headerlink" title="4. react-native 项目 IOS 引入， 使用 Objective-c 语法"></a>4. react-native 项目 IOS 引入， 使用 Objective-c 语法</h3><p>参考 <a target="_blank" rel="noopener" href="https://github.com/arthenica/ffmpeg-kit/tree/main/react-native/ios">FFmpegKit 仓库</a> 的写法就行，就是用 Objective-c 写的。<br>ios 的声明文件 podspec 文件和 ts 的导出文件 NativeModule.ts 和 swift 写法的一样就行。</p>

      
    </div>
    <footer class="article-footer">
      
      <!-- <a data-url="https://blog.cchealthier.com/2025/08/02/react-native-ffmpegkit-2/" data-id="cmefuc51h003iet9mhqjh1dl5" class="article-share-link">分享</a> -->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ffmpegkit/" rel="tag">ffmpegkit</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react-native/" rel="tag">react-native</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-native-ffmpegkit" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/07/27/react-native-ffmpegkit/" class="article-date">
  <time datetime="2025-07-27T03:20:53.000Z" itemprop="datePublished">2025-07-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/07/27/react-native-ffmpegkit/">react-native 集成 FFmpeg 能力 - 使用 FFmpegKit（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>相关文章：<br>《<a href="/2025/08/02/react-native-ffmpegkit-2/">react-native 集成 FFmpeg 能力 - 使用 FFmpegKit（二）</a>》<br>《<a href="/2025/08/17/react-native-ffmpegkit-3/">react-native 集成 FFmpeg 能力 - 使用 FFmpegKit（三）</a>》</p>
<p><strong><u>这一篇主要记录对于 react-native 库的使用。</u></strong></p>
<p>最近在做 react-native 的需求，需要做一些视频剪辑。ios 上使用的是 AVFoundation，询问了 AI 还比较顺利，功能实现了。Android 上使用的是 MediaCodec，就是怎么都调试不出来。AI 也直接建议用 FFmpeg 了。</p>
<h3 id="一、现状调研"><a href="#一、现状调研" class="headerlink" title="一、现状调研"></a>一、现状调研</h3><p><a target="_blank" rel="noopener" href="https://ffmpeg.org/">FFmpeg</a> 也是个很知名很强大的音视频处理工具了，一般用在命令行。在这个基础上，网上有大佬封装适配了多个平台的库，其中也包括 react-native，仓库地址 <a target="_blank" rel="noopener" href="https://github.com/arthenica/ffmpeg-kit">ffmpeg-kit</a>。很遗憾的是，今年年初因为人力资源问题，大佬停止了更新。</p>
<p>这里提到了：《<a target="_blank" rel="noopener" href="https://tanersener.medium.com/saying-goodbye-to-ffmpegkit-33ae939767e1">Saying Goodbye to FFmpegKit</a>》。感谢大佬们的用爱发电啊。</p>
<p>截止到当前，FFmpeg 版本是 7，FFmpegKit 封装的版本是 6。同时 FFmpegKit 也删除了 IOS 和 Android 仓库里的库，所以 react-native 的也用不了了。但是仓库源码还在。所以目前还想继续使用 FFmpegKit 的话，可以：</p>
<ol>
<li>找之前网上保留过的资源，或者其他大佬私下打包出来分享的。</li>
<li>自己根据源码打包，因为不维护了，自己解决打包出现的问题。</li>
</ol>
<h3 id="二、资源准备"><a href="#二、资源准备" class="headerlink" title="二、资源准备"></a>二、资源准备</h3><p>当然找到了资源包，也得自己引入，因为正常的安装流程已经报错了，得本地引入（自己打包放到网上仓库也可以），首先：</p>
<p><strong>Android</strong> - <a target="_blank" rel="noopener" href="https://artifactory.appodeal.com/appodeal-public/com/arthenica/ffmpeg-kit-full-gpl/6.0-2.LTS/">aar 下载</a>，然后在本地引入。<br><strong>IOS</strong> - <a target="_blank" rel="noopener" href="https://luthviar.medium.com/%EF%B8%8F-resolved-ffmpegkit-retirement-issue-in-ios-a-complete-guide-with-cocoapods-support-e3caac7192e0">参考文章</a>，可以将 podFile 指向 FFmpegKit 原仓库的地址改成指向「<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/luthviar/ffmpeg-kit-ios-full/main/ffmpeg-kit-ios-full.podspec">别的地址</a>」（其实就是这个文章作者大佬自己的仓库），保证能下载到依赖压缩包就行，也可以根据这份 podspec 文件里面指向的 zip 包地址，把依赖包下载下来，放在自己本地引入。</p>
<h3 id="三、react-native-库引入使用"><a href="#三、react-native-库引入使用" class="headerlink" title="三、react-native 库引入使用"></a>三、react-native 库引入使用</h3><p>react-native 库：《<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/ffmpeg-kit-react-native">ffmpeg-kit-react-native</a>》，原《<a target="_blank" rel="noopener" href="https://github.com/arthenica/ffmpeg-kit/tree/main/react-native">使用文档</a>》，现在安装这个库会报已经废弃的警告。</p>
<p>现在在获得 IOS 和 Android 依赖包的情况下，进行本地引入，使得 react-native 库也能用起来。当然相应的 IOS 和 Android 库也能用。<br>首先在项目根目录放置两个依赖库（地址随意，用的时候正确使用就行）：</p>
<img src="/2025/07/27/react-native-ffmpegkit/%E4%BE%9D%E8%B5%96%E5%8C%85%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84.png" class="" title="依赖包文件路径">

<p>ios 文件夹有一个 <strong>ffmpeg-kit-ios-video.podspec</strong> 文件，这不是资源包下载下来附带的，要自己添加，相当于依赖声明。</p>
<h4 id="Android-端修复使用"><a href="#Android-端修复使用" class="headerlink" title="Android 端修复使用"></a>Android 端修复使用</h4><p>Android 端的使用还是比较简单的，直接打 patch 修改 node_modules 里的文件内容就行：找到 node_modules&#x2F;ffmpeg-kit-react-native&#x2F;android&#x2F;build.gradle 文件，修改成一下这样即可：</p>
<pre><code>dependencies &#123;
  api &#39;com.facebook.react:react-native:+&#39;
  // 这句注释：implementation &#39;com.arthenica:ffmpeg-kit-&#39; + safePackageName(safeExtGet(&#39;ffmpegKitPackage&#39;, &#39;https&#39;)) + &#39;:&#39; + safePackageVersion(safeExtGet(&#39;ffmpegKitPackage&#39;, &#39;https&#39;))
  // 添加下面两句，引入本地依赖和其他依赖
  implementation files(&#39;../../../libs/android/ffmpeg-kit.aar&#39;)
  implementation &#39;com.arthenica:smart-exception-java:0.2.1&#39;
&#125;
</code></pre>
<h4 id="IOS-端修复使用"><a href="#IOS-端修复使用" class="headerlink" title="IOS 端修复使用"></a>IOS 端修复使用</h4><h5 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h5><p>首先上面提到的 <strong>ffmpeg-kit-ios-video.podspec</strong>：</p>
<pre><code>Pod::Spec.new do |s|
  s.name         = &#39;ffmpeg-kit-ios-video&#39;
  s.version      = &#39;6.0&#39;
  s.summary      = &#39;FFmpeg Kit for React Native&#39;
  s.homepage     = &#39;https://github.com/arthenica/ffmpeg-kit&#39;
  s.license      = &#39;LGPL-3.0&#39;
  s.authors      = &#39;author&#39;
  s.platform          = :ios
  s.requires_arc      = true
  s.static_framework  = true
  s.source       = &#123; path: &#39;.&#39; &#125;
  s.dependency &quot;React-Core&quot;
  s.vendored_frameworks = &#39;*.xcframework&#39;
end
</code></pre>
<h5 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h5><p>然后项目下找到 <strong>ios&#x2F;Podfile</strong> 文件，修改：</p>
<pre><code>// 备用：pod &#39;ffmpeg-kit-ios-full&#39;, :podspec =&gt; &#39;https://raw.githubusercontent.com/luthviar/ffmpeg-kit-ios-full/main/ffmpeg-kit-ios-full.podspec&#39;
pod &#39;ffmpeg-kit-ios-video&#39;, :path =&gt; &#39;../libs/ios/ffmpeg-kit-ios-video&#39;
pod &#39;ffmpeg-kit-react-native&#39;, :subspecs =&gt; [&#39;video&#39;], :podspec =&gt; &#39;../node_modules/ffmpeg-kit-react-native/ffmpeg-kit-react-native.podspec&#39;
// 找到下面这一句，然后在这一句上面添加上面那两句，顺序严格
config = use_native_modules!(config_command)
</code></pre>
<p>注意：这里的依赖库名是 <code>ffmpeg-kit-ios-video</code>，是因为我自己本地打了个 video 包出来，所以命名为 video 后缀。如果自己打出来了别的包，或者网上找的包是 full 或者别的名字，只要把所有相应的名字改了就行。</p>
<p>比如 <code>ffmpeg-kit-ios-video</code> 全改成 <code>ffmpeg-kit-ios-full</code>，包括那个 libs&#x2F;ios 下的 podspec 文件。<br><code>:subspecs =&gt; [&#39;video&#39;]</code> 理论上应该也没影响了，不过也最好改一下，改成：<code>:subspecs =&gt; [&#39;full&#39;]</code>。</p>
<h5 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h5><p>如果是 expo 项目，这里有个小问题。ios 文件夹都是每次 build 生成的，当然里面的 Podfile 文件也是，也就是每次重新创建文件，都要自己去打这个补丁。太麻烦了，所以得换另外方式。<br><strong>注意下面示例我是用了 ffmpeg-kit-ios-full 的包，这个和自己本地引入的实际包名保持一致就好了。</strong></p>
<p>用官方的工具 <a target="_blank" rel="noopener" href="https://docs.expo.dev/versions/unversioned/sdk/build-properties/">expo-build-properties</a>，在 app.config.ts 文件加上：</p>
<pre><code class="ts">const config = &#123;
  // 其他省略
  plugins: [
    [
      &#39;expo-build-properties&#39;,
      &#123;
        ios: &#123;
          extraPods: [
            &#123;
              name: &#39;ffmpeg-kit-ios-full&#39;,
              path: &#39;../libs/ios/ffmpeg-kit-ios-full&#39;, // 本地路径（相对于 ios/Podfile）
            &#125;,
            &#123;
              name: &#39;ffmpeg-kit-react-native&#39;,
              podspec:
                  &#39;../node_modules/ffmpeg-kit-react-native/ffmpeg-kit-react-native.podspec&#39;, // 本地路径（相对于 ios/Podfile）
            &#125;,
          ],
        &#125;,
      &#125;,
    ],
  ],
&#125;
</code></pre>
<p>这样，每次 build 创建 ios&#x2F;Podfile 文件时候，就会打上上面的补丁。可以看到上面是打了两份补丁，一个 ffmpeg-kit 本身，自己使用本地引入的。一个是对应的 react-native 库，指向了 node_modules 里的文件，但是这个 react-native 库 podspec 文件已经知道是有问题的。<br>所以还要再对 node_modules 的 ffmpeg-kit-react-native 依赖包再打一份针对 ios 的 patch：</p>
<pre><code>Pod::Spec.new do |s|
  s.source       = &#123; :git =&gt; &quot;https://github.com/arthenica/ffmpeg-kit.git&quot;, :tag =&gt; &quot;react.native.v#&#123;s.version&#125;&quot; &#125;
  s.dependency &quot;React-Core&quot;
  s.source_files      = &#39;**/FFmpegKitReactNativeModule.m&#39;,
    &#39;**/FFmpegKitReactNativeModule.h&#39;
  s.dependency &#39;ffmpeg-kit-ios-full&#39;, &quot;6.0&quot;
  s.ios.deployment_target = &#39;10&#39;
end
</code></pre>
<h3 id="四、测试使用"><a href="#四、测试使用" class="headerlink" title="四、测试使用"></a>四、测试使用</h3><p>本地库和配置文件都准备完毕，因为改了原生依赖，所以最好重新编译一遍。我使用的是 expo 项目，可以执行：<code>npx expo prebuild --clean</code> 重新安装一遍。<br>如果用的纯 react-native 项目，就用 xcode 和 Android Studio 重新安装。</p>
<p>在代码里测试是否引用成功：</p>
<pre><code class="js">import &#123; ReturnCode &#125; from &#39;ffmpeg-kit-react-native&#39;;
FFmpegKitConfig.getFFmpegVersion().then(v =&gt; console.log(&#39;getFFmpegVersion&#39;, v))
</code></pre>

      
    </div>
    <footer class="article-footer">
      
      <!-- <a data-url="https://blog.cchealthier.com/2025/07/27/react-native-ffmpegkit/" data-id="cmefuc51i003pet9md4h4haiy" class="article-share-link">分享</a> -->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ffmpegkit/" rel="tag">ffmpegkit</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react-native/" rel="tag">react-native</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-use-swr" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/03/16/use-swr/" class="article-date">
  <time datetime="2025-03-16T03:52:51.000Z" itemprop="datePublished">2025-03-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/03/16/use-swr/">react 使用 swr 做数据请求</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>官网介绍：<a target="_blank" rel="noopener" href="https://swr.vercel.app/">用于数据请求的 React Hooks 库</a></p>
<p>一开始想着不就是把请求变成 hook 写法来用吗？就是多了一个方便 loading 标志位的处理。抱着试一试的心态用了，用着用着感觉还挺不错，记录下使用方法。</p>
<h3 id="一、基础用法"><a href="#一、基础用法" class="headerlink" title="一、基础用法"></a>一、基础用法</h3><p>在一些进入页面就要请求的场景里，比如列表页，配置项什么的，特别合适。传统的写法可能是 <code>useEffect(() =&gt; &#123;&#125;, [])</code> 里触发一下接口请求。用了 swr 后就可以不用这么写了，官网示例：</p>
<pre><code class="js">import useSWR from &#39;swr&#39;
 
function Profile() &#123;
  const &#123; data, error, isLoading, mutate &#125; = useSWR(&#39;/api/user&#39;, fetcher)
 
  if (error) return &lt;div&gt;failed to load&lt;/div&gt;
  if (isLoading) return &lt;div&gt;loading...&lt;/div&gt;
  return &lt;div&gt;hello &#123;data.name&#125;!&lt;/div&gt;
&#125;
</code></pre>
<p>在传统场景可能就需要声明一个 loading 变量，然后自行管理，先 setLoading(true) 又 setLoading(false)。同理，data 也得用 useState 处理一下。这里直接把数据、错误，等待标志位，摊平来使用。页面一多，还是便利不少的，特别是 B 端的列表页面。在编辑完信息后，需要更新内容可以主动调用一次 <code>mutate</code> 来触发一次请求。</p>
<h3 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h3><p>众所周知，hook 不能写在条件里，所以这个很适合写在一开始必须请求的场景。当然 swr 也是预留了这个场景，如果开始传入的是空路径，就不会请求。也是官网示例：<a target="_blank" rel="noopener" href="https://swr.vercel.app/zh-CN/docs/conditional-fetching">条件数据请求</a></p>
<pre><code class="js">function Profile () &#123;
  const &#123; data &#125; = useSWR(isReady ? &#39;/api/user&#39; : null, fetcher, &#123; suspense: true &#125;)
 
  // 如果 `isReady` 是 false，`data` 将会是 `undefined`
  // ...
&#125;
</code></pre>
<p>这个可以在需要有前置条件的时候，比如第二个接口依赖于第一个接口返回的某个字段，这时候就可以先这样按住第二个接口。</p>
<p>这个也可以用于用户行为后的请求，比如按钮点击后的，登录什么的。但我觉得这种场景下，用 swr 就很别扭。而且一般都会把接口声明在一个地方，方便维护。那么此时这两种场景下的接口写法就不一样，会出现一部分接口一定是夹杂了条件判断。</p>
<p>所以，我认为接口还是按照原来的声明，只是在列表之类的接口，要使用的时候再看情况用 swr 包装一层。如：</p>
<pre><code class="js">const getUser = () =&gt; fetcher(&#39;/api/user&#39;)

function Profile() &#123;
  const &#123; data, error, isLoading &#125; = useSWR(&#39;/api/user&#39;, () =&gt; getUser())
&#125;
</code></pre>
<h3 id="三、携带参数"><a href="#三、携带参数" class="headerlink" title="三、携带参数"></a>三、携带参数</h3><p>接口免不了要携带参数，比如列表搜索也有一堆过滤参数，可以这样写：</p>
<pre><code class="js">import useSWR from &#39;swr&#39;
 
function Profile() &#123;
  const [formData] = useState(&#123; a: 1 &#125;)
  const &#123; data, error, isLoading &#125; = useSWR([&#39;/api/user&#39;, formData], ([, params]) =&gt; fetcher(params))
&#125;

// 不要写成下面这种
// function Profile() &#123;
//   const [formData] = useState(&#123; a: 1 &#125;)
//   const &#123; data, error, isLoading &#125; = useSWR(&#39;/api/user&#39;, () =&gt; fetcher(formData))
// &#125;
</code></pre>
<p>这样可以达到修改参数 formData 的时候，就会自动触发带上新的参数一次请求。**注意不要写成上面第二种，这样参数相当于写在闭包里，再次请求会变成携带旧的参数。</p>
<h3 id="四、工具参数"><a href="#四、工具参数" class="headerlink" title="四、工具参数"></a>四、工具参数</h3><p>有一些很实用的参数：<a target="_blank" rel="noopener" href="https://swr.vercel.app/zh-CN/docs/api#options">选项</a>，这里列举几个改到默认配置的：</p>
<ul>
<li><code>keepPreviousData</code> 改为 true，默认为 false，在列表重新请求时会把数据先置空，这时列表就白了。改为 true 后就是数据来了再更新，不会有这个闪的效果。</li>
<li><code>revalidateOnFocus</code> 改为 false，默认为 true，在切换 tab 的时候，回到本页面也就是页面 focus 事件触发一次请求，可能大部分场景不需要这样。</li>
<li><code>focusThrottleInterval</code> 如果需要聚焦时再度请求，可以搭配这个限流一下。</li>
<li><code>refreshInterval</code> 这个就顾名思义了，开启轮询。</li>
</ul>
<p>可以单个使用：</p>
<pre><code class="js">const &#123; data &#125; = useSWR(&#39;/api/user&#39;, fetcher, &#123; keepPreviousData: true &#125;)
</code></pre>
<p>每个都写太麻烦，可以全局配置，然后个别灵活处理：</p>
<pre><code class="html">&lt;SWRConfig value=&#123;&#123; keepPreviousData: true &#125;&#125;&gt;
  &lt;Page /&gt;
&lt;/SWRConfig&gt;
</code></pre>

      
    </div>
    <footer class="article-footer">
      
      <!-- <a data-url="https://blog.cchealthier.com/2025/03/16/use-swr/" data-id="cmefuc51k004eet9m84qjd4bk" class="article-share-link">分享</a> -->
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-chrome-extension-plugin" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/01/11/chrome-extension-plugin/" class="article-date">
  <time datetime="2025-01-11T13:13:03.000Z" itemprop="datePublished">2025-01-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/01/11/chrome-extension-plugin/">chrome 插件基础模板</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一直以来，都觉得 chrome 插件挺方便的，可以做出灵活又好用的工具。工作中也接触过一些插件的开发，但是都没有系统的了解下。这次花点时间记录下。</p>
<p>因为刚好发现这个工具《<a target="_blank" rel="noopener" href="https://crxjs.dev/vite-plugin">What is CRXJS</a>》，用 vite 做开发工具，支持前端框架有 react、vue、solid 等。这样一来就省了很多事了，chrome 插件也可以使用漂漂亮亮的组件库了。</p>
<p>具体有《<a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/extensions/get-started/tutorial/hello-world?hl=zh-cn">官方文档</a>》，这里记录一下快速使用的点。</p>
<p>工程地址：《<a target="_blank" rel="noopener" href="https://github.com/orochi97/chrome-extension-plugin-demo">chrome-extension-plugin-demo</a>》</p>
<p><strong>注意：</strong><br><strong>1. 最新 chrome 浏览器版本已经禁止的 manifest_version 2 版本的使用了，现在开始都是 3 了。</strong><br><strong>2. 这个 @crxjs&#x2F;vite-plugin 工具要使用 beta 版本，latest 在 manifest_version 3 会因为资源安全问题加载报错。</strong></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>以 <code>manifest</code> 的字段为介绍：</p>
<pre><code class="json">&#123;
  &quot;manifest_version&quot;: 3,
  &quot;name&quot;: &quot;Chrome Extension&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;Chrome Extension React Vite Example&quot;,
  &quot;permissions&quot;: [&quot;tabs&quot;, &quot;notifications&quot;],
  &quot;action&quot;: &#123;
    &quot;default_popup&quot;: &quot;src/popup/index.html&quot;,
    &quot;default_icon&quot;: &quot;src/assets/images/icon.png&quot;
  &#125;,
  &quot;icons&quot;: &#123;
    &quot;16&quot;: &quot;src/assets/images/icon-16.png&quot;,
    &quot;32&quot;: &quot;src/assets/images/icon-32.png&quot;,
    &quot;48&quot;: &quot;src/assets/images/icon-48.png&quot;,
    &quot;128&quot;: &quot;src/assets/images/icon-128.png&quot;
  &#125;,
  &quot;background&quot;: &#123;
    &quot;service_worker&quot;: &quot;src/background/index.ts&quot;,
    &quot;type&quot;: &quot;module&quot;
  &#125;,
  &quot;content_scripts&quot;: [
    &#123;
      &quot;js&quot;: [&quot;src/scripts/content.ts&quot;],
      &quot;matches&quot;: [&quot;&lt;all_urls&gt;&quot;]
    &#125;
  ]
&#125;
</code></pre>
<ul>
<li>permissions：声明要开通的模块，不然调用 api 会失败。</li>
<li>action：就是右上角插件面板里，那个按钮点击后弹出框的入口文件和显示图标。</li>
<li>background：后台运行的代码，这里可以调用的 api 更全一点。可以指定以 es module 模式加载。</li>
<li>content_scripts：会嵌入到当前访问网站里，可以读取当前网站的 dom，storage 等，实际就是当前网站的一部分了。matches 可以指定哪些网站可以嵌入。具体可以看《<a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/extensions/develop/concepts/match-patterns?hl=zh-cn">匹配模式</a>》。</li>
</ul>
<p>示例工程，用了多页面，但是这个 @crxjs&#x2F;vite-plugin 只默认加载了 action 做入口文件。所以要自己配一下其它入口页面。</p>
<pre><code class="ts">import &#123; resolve &#125; from &#39;node:path&#39;;
import &#123; defineConfig &#125; from &#39;vite&#39;;
import react from &#39;@vitejs/plugin-react&#39;;
import &#123; crx, type ManifestV3Export &#125; from &#39;@crxjs/vite-plugin&#39;;
import manifest from &#39;./manifest.json&#39;;

export default defineConfig(&#123;
  plugins: [react(), crx(&#123; manifest: manifest as ManifestV3Export &#125;)],
  build: &#123;
    rollupOptions: &#123;
      input: &#123;
        main: resolve(__dirname, &#39;src/main/index.html&#39;),
      &#125;,
    &#125;,
  &#125;,
&#125;);
</code></pre>
<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>像往常一样启动 vite 工程就行，只不过配置了开发时也把文件存在硬盘，因为要丢到插件库里去运行。执行 <code>pnpm dev</code> 后就会产出 <code>dist</code> 文件夹，浏览器打开 <code>chrome://extensions/</code>，然后把整个 dist 文件夹往浏览器界面拖就行。当然右上角的开发者模式要打开。<br>chrome:&#x2F;&#x2F;extensions 页面 “所有扩展程序” 下，有自己的开发程序那就是成功了。大部分代码更新都是可以马上生效不需要刷新加载的。改了配置之类的就得刷新加载，此时点击该插件面板右下角的刷新按钮就行了。</p>

      
    </div>
    <footer class="article-footer">
      
      <!-- <a data-url="https://blog.cchealthier.com/2025/01/11/chrome-extension-plugin/" data-id="cmefuc517000ket9m5oeb5ue2" class="article-share-link">分享</a> -->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/chrome-%E6%8F%92%E4%BB%B6/" rel="tag">chrome 插件</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/">下一页 »</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/08/17/react-native-ffmpegkit-3/">react-native 集成 FFmpeg 能力 - 使用 FFmpegKit（三）</a>
          </li>
        
          <li>
            <a href="/2025/08/02/react-native-ffmpegkit-2/">react-native 集成 FFmpeg 能力 - 使用 FFmpegKit（二）</a>
          </li>
        
          <li>
            <a href="/2025/07/27/react-native-ffmpegkit/">react-native 集成 FFmpeg 能力 - 使用 FFmpegKit（一）</a>
          </li>
        
          <li>
            <a href="/2025/03/16/use-swr/">react 使用 swr 做数据请求</a>
          </li>
        
          <li>
            <a href="/2025/01/11/chrome-extension-plugin/">chrome 插件基础模板</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/http%E5%8D%8F%E8%AE%AE/">http协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1/">服务</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/%E7%AE%97%E6%B3%95/">算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%85%E8%A1%8C/">旅行</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%85%E8%A1%8C/%E8%AE%B0%E5%BD%95/">记录</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%83%B9%E9%A5%AA/">烹饪</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%83%B9%E9%A5%AA/%E4%BC%A0%E7%BB%9F/">传统</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E6%83%B3/">随想</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E6%83%B3/%E5%BF%83%E6%83%85/">心情</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/chrome-%E6%8F%92%E4%BB%B6/" rel="tag">chrome 插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ffmpegkit/" rel="tag">ffmpegkit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/" rel="tag">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react-native/" rel="tag">react-native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssr/" rel="tag">ssr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/" rel="tag">微前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD/" rel="tag">性能</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/chrome-%E6%8F%92%E4%BB%B6/" style="font-size: 10px;">chrome 插件</a> <a href="/tags/ffmpegkit/" style="font-size: 14px;">ffmpegkit</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/nginx/" style="font-size: 12px;">nginx</a> <a href="/tags/node/" style="font-size: 16px;">node</a> <a href="/tags/react-native/" style="font-size: 18px;">react-native</a> <a href="/tags/ssr/" style="font-size: 10px;">ssr</a> <a href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 20px;">工程化</a> <a href="/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/" style="font-size: 12px;">微前端</a> <a href="/tags/%E6%80%A7%E8%83%BD/" style="font-size: 16px;">性能</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">八月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">七月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">三月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">一月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">十一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">九月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">十二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">十一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">十月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 ChrisIori<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    

<script src="//cdn.staticfile.org/jquery/2.0.3/jquery.min.js"></script>
<script type="text/javascript" src="https://www.jq22.com/demo/jqueryToast201708310012/js/toast.script.js"></script>
<script src="/js/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<script>
  $(function(){
    $('pre code').each((i, el) => {
    hljs.highlightElement(el);
  });
  $('code.hljs').each(function(i, el) {
     hljs.lineNumbersBlock(el);
  });
  }());
</script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>